<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Automated Deadlock Detection — Frontend Demo</title>
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --muted:#97a0b3; --accent:#60a5fa; --danger:#fb7185; --ok:#34d399;
      --glass: rgba(255,255,255,0.03);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071029 0%, #081227 100%);color:#e6eef8}
    .wrap{max-width:1100px;margin:28px auto;padding:20px}
    header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
    h1{margin:0;font-size:20px}
    p.lead{margin:0;color:var(--muted);font-size:13px}

    .grid{display:grid;grid-template-columns:360px 1fr;gap:16px}
    .card{background:var(--card);border-radius:12px;padding:14px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}
    .section-title{font-size:13px;margin:0 0 8px 0;color:var(--accent)}
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    input,select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}
    .row{display:flex;gap:8px}
    button{background:var(--accent);color:#04203a;padding:8px 10px;border:none;border-radius:8px;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    .small{font-size:13px;padding:6px 8px}
    .list{max-height:220px;overflow:auto;margin-top:8px;border-radius:8px;padding:8px;background:var(--glass)}
    .item{display:flex;justify-content:space-between;align-items:center;padding:6px;border-radius:6px}
    .item span.name{font-weight:600}
    .controls{display:flex;gap:6px}

    /* visualization */
    .viz-wrap{display:flex;flex-direction:column;height:720px}
    .viz-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .svg-area{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:10px;padding:8px}
    svg{width:100%;height:100%;overflow:visible}

    .legend{display:flex;gap:8px;align-items:center;color:var(--muted)}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}

    .summary{margin-top:10px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--muted)}
    pre{white-space:pre-wrap;margin:0;color:#d8e8ff}

    footer{margin-top:12px;color:var(--muted);font-size:13px}

    /* small screens */
    @media (max-width:900px){.grid{grid-template-columns:1fr;}.viz-wrap{height:520px}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Automated Deadlock Detection — Frontend Demo</h1>
        <p class="lead">Enter processes, resources, set holds/waits, and detect deadlocks visually (no backend required).</p>
      </div>
      <div style="margin-left:auto;color:var(--muted);font-size:13px">Local demo • Single-file</div>
    </header>

    <div class="grid">
      <div>
        <div class="card">
          <p class="section-title">Create Entities</p>
          <label>Process name</label>
          <div class="row" style="margin-bottom:8px">
            <input id="procName" placeholder="e.g., P1" />
            <button id="addProc">Add</button>
          </div>

          <label>Resource name</label>
          <div class="row" style="margin-bottom:8px">
            <input id="resName" placeholder="e.g., R1" />
            <button id="addRes">Add</button>
          </div>

          <p class="section-title" style="margin-top:12px">Set Hold / Wait</p>
          <label>Holder (process)</label>
          <select id="holdProc"></select>
          <label>Resource held</label>
          <select id="holdRes"></select>
          <div style="margin-top:8px" class="row">
            <button id="addHold" class="small">Add Hold</button>
            <button id="clearHolds" class="small secondary">Clear Holds</button>
          </div>

          <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)" />

          <label>Waiting Process</label>
          <select id="waitProc"></select>
          <label>Resource waiting for</label>
          <select id="waitRes"></select>
          <div style="margin-top:8px" class="row">
            <button id="addWait" class="small">Add Wait</button>
            <button id="clearWaits" class="small secondary">Clear Waits</button>
          </div>

          <p class="section-title" style="margin-top:12px">Quick Samples</p>
          <div style="display:flex;gap:6px;margin-bottom:8px">
            <button id="sample1" class="small secondary">Simple Deadlock</button>
            <button id="sample2" class="small secondary">No Deadlock</button>
            <button id="resetAll" class="small">Reset</button>
          </div>

          <p class="section-title">Lists</p>
          <div class="list" id="lists">
            <!-- dynamic lists here -->
          </div>

        </div>
      </div>

      <div class="viz-wrap">
        <div class="card" style="flex:0 0 auto;padding:10px;border-radius:12px;margin-bottom:8px;display:flex;align-items:center;justify-content:space-between">
          <div style="display:flex;gap:12px;align-items:center">
            <div style="font-weight:700">Graph</div>
            <div class="legend">
              <div class="chip">● Process</div>
              <div class="chip">■ Resource</div>
              <div class="chip" style="color:var(--muted)">→ Hold (solid)</div>
              <div class="chip" style="color:var(--muted)">→ Wait (dashed)</div>
            </div>
          </div>
          <div style="display:flex;gap:8px">
            <button id="detect" class="small">Detect Deadlock</button>
            <button id="downloadReport" class="small secondary">Download Report</button>
          </div>
        </div>

        <div class="svg-area card" id="svgCard">
          <svg id="svg" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid meet"></svg>
        </div>

        <div class="card summary" id="summary">
          <strong id="resultTitle">No analysis run yet.</strong>
          <div id="resultBody" style="margin-top:8px;color:var(--muted)">Add entities and then click <em>Detect Deadlock</em>.</div>
        </div>
      </div>
    </div>

    <footer>Tip: Use the sample configurations to quickly test. Cycle edges are highlighted in red.</footer>
  </div>

  <script>
    // Data model
    const state = {
      processes: [], // ['P1']
      resources: [], // ['R1']
      holds: [],    // {proc:'P1', res:'R1'}
      waits: []     // {proc:'P2', res:'R1'}
    };

    // DOM refs
    const procName = document.getElementById('procName');
    const resName = document.getElementById('resName');
    const addProcBtn = document.getElementById('addProc');
    const addResBtn = document.getElementById('addRes');
    const holdProc = document.getElementById('holdProc');
    const holdRes = document.getElementById('holdRes');
    const addHoldBtn = document.getElementById('addHold');
    const waitProc = document.getElementById('waitProc');
    const waitRes = document.getElementById('waitRes');
    const addWaitBtn = document.getElementById('addWait');
    const lists = document.getElementById('lists');
    const detectBtn = document.getElementById('detect');
    const svg = document.getElementById('svg');
    const resultTitle = document.getElementById('resultTitle');
    const resultBody = document.getElementById('resultBody');
    const downloadReport = document.getElementById('downloadReport');

    // helpers
    function unique(arr){return [...new Set(arr)];}

    function refreshSelects(){
      const procs = state.processes;
      const ress = state.resources;
      [holdProc, waitProc].forEach(sel=>{
        sel.innerHTML='';
        const opt = document.createElement('option'); opt.value=''; opt.textContent='-- select --'; sel.appendChild(opt);
        procs.forEach(p=>{const o=document.createElement('option');o.value=p;o.textContent=p;sel.appendChild(o)})
      });
      [holdRes, waitRes].forEach(sel=>{
        sel.innerHTML='';
        const opt = document.createElement('option'); opt.value=''; opt.textContent='-- select --'; sel.appendChild(opt);
        ress.forEach(r=>{const o=document.createElement('option');o.value=r;o.textContent=r;sel.appendChild(o)})
      });
      renderLists();
    }

    function renderLists(){
      lists.innerHTML = '';
      const pBox = document.createElement('div');
      pBox.innerHTML = '<div style="font-weight:700;margin-bottom:6px">Processes</div>';
      state.processes.forEach(p=>{
        const it = document.createElement('div'); it.className='item';
        it.innerHTML = `<div><span class='name'>${p}</span></div><div class='controls'><button class='small secondary' onclick="removeProc('${p}')">Del</button></div>`;
        pBox.appendChild(it);
      });
      const rBox = document.createElement('div'); rBox.style.marginTop='10px'; rBox.innerHTML = '<div style="font-weight:700;margin-bottom:6px">Resources</div>';
      state.resources.forEach(r=>{
        const it = document.createElement('div'); it.className='item';
        it.innerHTML = `<div><span class='name'>${r}</span></div><div class='controls'><button class='small secondary' onclick="removeRes('${r}')">Del</button></div>`;
        rBox.appendChild(it);
      });

      const hBox = document.createElement('div'); hBox.style.marginTop='10px'; hBox.innerHTML = '<div style="font-weight:700;margin-bottom:6px">Holds</div>';
      state.holds.forEach((h,i)=>{
        const it = document.createElement('div'); it.className='item';
        it.innerHTML = `<div>${h.proc} → ${h.res}</div><div class='controls'><button class='small secondary' onclick="removeHold(${i})">Del</button></div>`;
        hBox.appendChild(it);
      });

      const wBox = document.createElement('div'); wBox.style.marginTop='10px'; wBox.innerHTML = '<div style="font-weight:700;margin-bottom:6px">Waits</div>';
      state.waits.forEach((w,i)=>{
        const it = document.createElement('div'); it.className='item';
        it.innerHTML = `<div>${w.proc} waits → ${w.res}</div><div class='controls'><button class='small secondary' onclick="removeWait(${i})">Del</button></div>`;
        wBox.appendChild(it);
      });

      lists.appendChild(pBox); lists.appendChild(rBox); lists.appendChild(hBox); lists.appendChild(wBox);
    }

    // CRUD actions
    function addProc(){
      const name = procName.value.trim(); if(!name) return alert('Enter process name');
      if(state.processes.includes(name)) return alert('Already exists');
      state.processes.push(name); refreshSelects(); procName.value='';
    }
    function addRes(){
      const name = resName.value.trim(); if(!name) return alert('Enter resource name');
      if(state.resources.includes(name)) return alert('Already exists');
      state.resources.push(name); refreshSelects(); resName.value='';
    }
    function removeProc(name){
      state.processes = state.processes.filter(p=>p!==name);
      state.holds = state.holds.filter(h=>h.proc!==name);
      state.waits = state.waits.filter(w=>w.proc!==name);
      refreshSelects(); drawGraph();
    }
    function removeRes(name){
      state.resources = state.resources.filter(r=>r!==name);
      state.holds = state.holds.filter(h=>h.res!==name);
      state.waits = state.waits.filter(w=>w.res!==name);
      refreshSelects(); drawGraph();
    }
    function removeHold(i){state.holds.splice(i,1); refreshSelects(); drawGraph();}
    function removeWait(i){state.waits.splice(i,1); refreshSelects(); drawGraph();}

    addProcBtn.onclick = addProc; addResBtn.onclick = addRes;
    addHoldBtn.onclick = ()=>{
      const p=holdProc.value, r=holdRes.value; if(!p||!r) return alert('Select holder and resource');
      // avoid duplicates
      if(state.holds.find(h=>h.proc===p&&h.res===r)) return alert('Hold already added');
      state.holds.push({proc:p,res:r}); refreshSelects(); drawGraph();
    }
    addWaitBtn.onclick = ()=>{
      const p=waitProc.value, r=waitRes.value; if(!p||!r) return alert('Select waiting process and resource');
      if(state.waits.find(w=>w.proc===p&&w.res===r)) return alert('Wait already added');
      state.waits.push({proc:p,res:r}); refreshSelects(); drawGraph();
    }

    document.getElementById('clearHolds').onclick = ()=>{state.holds=[];refreshSelects();drawGraph();}
    document.getElementById('clearWaits').onclick = ()=>{state.waits=[];refreshSelects();drawGraph();}
    document.getElementById('resetAll').onclick = ()=>{if(!confirm('Reset everything?')) return; state.processes=[];state.resources=[];state.holds=[];state.waits=[];refreshSelects();drawGraph();resultTitle.textContent='Reset complete.';resultBody.textContent='';}

    // sample scenarios
    document.getElementById('sample1').onclick = ()=>{
      // Simple deadlock: P1 holds R1; P2 holds R2; P1 waits R2; P2 waits R1
      state.processes=['P1','P2']; state.resources=['R1','R2']; state.holds=[{proc:'P1',res:'R1'},{proc:'P2',res:'R2'}]; state.waits=[{proc:'P1',res:'R2'},{proc:'P2',res:'R1'}]; refreshSelects(); drawGraph(); resultTitle.textContent='Loaded sample: Simple Deadlock'; resultBody.textContent='Click Detect Deadlock to analyze.';
    }
    document.getElementById('sample2').onclick = ()=>{
      // No deadlock: P1 holds R1; P2 waits R1; P2 holds R2
      state.processes=['P1','P2']; state.resources=['R1','R2']; state.holds=[{proc:'P1',res:'R1'},{proc:'P2',res:'R2'}]; state.waits=[{proc:'P2',res:'R1'}]; refreshSelects(); drawGraph(); resultTitle.textContent='Loaded sample: No Deadlock'; resultBody.textContent='Click Detect Deadlock to analyze.';
    }

    // Build wait-for graph: nodes are processes; edge P_a -> P_b if P_a waits for R and P_b holds R
    function buildWaitForGraph(){
      const graph = {};
      state.processes.forEach(p=>graph[p]=[]);
      state.waits.forEach(w=>{
        const holders = state.holds.filter(h=>h.res===w.res).map(h=>h.proc);
        holders.forEach(hp=>{
          if(!graph[w.proc]) graph[w.proc]=[];
          if(hp!==w.proc && !graph[w.proc].includes(hp)) graph[w.proc].push(hp);
        })
      })
      return graph;
    }

    // DFS cycle detection that returns a cycle path (array) or null
    function findCycle(graph){
      const visited = new Set();
      const stack = [];
      const onstack = new Set();
      let foundCycle = null;

      function dfs(node){
        if(foundCycle) return true;
        visited.add(node); stack.push(node); onstack.add(node);
        const neigh = graph[node]||[];
        for(const n of neigh){
          if(!visited.has(n)){
            if(dfs(n)) return true;
          } else if(onstack.has(n)){
            // cycle found: extract path from stack
            const idx = stack.indexOf(n);
            foundCycle = stack.slice(idx).concat(n); // close cycle
            return true;
          }
        }
        stack.pop(); onstack.delete(node);
        return false;
      }

      for(const node in graph){ if(!visited.has(node)) { if(dfs(node)) break; } }
      return foundCycle; // array path or null
    }

    // Drawing
    function drawGraph(cycle=null){
      // build positions: processes left column, resources right column
      const width = 1100, height = 620, margin=40;
      const px = 200, rx = width-200;
      const pCount = state.processes.length, rCount = state.resources.length;
      const pGap = Math.max(80, (height-2*margin)/Math.max(1,pCount));
      const rGap = Math.max(80, (height-2*margin)/Math.max(1,rCount));

      svg.setAttribute('viewBox',`0 0 ${width} ${height}`);
      svg.innerHTML = '';

      const procPositions = {};
      const resPositions = {};

      state.processes.forEach((p,i)=>{ const y = margin + i*pGap + 40; procPositions[p] = {x:px,y}; });
      state.resources.forEach((r,i)=>{ const y = margin + i*rGap + 40; resPositions[r] = {x:rx,y}; });

      // draw holds as solid arrows from process -> resource
      state.holds.forEach(h=>{
        const from = procPositions[h.proc]; const to = resPositions[h.res];
        if(!from||!to) return;
        const path = makeArrowPath(from.x+28, from.y, to.x-28, to.y);
        const el = createPathElement(path, 'hold'); svg.appendChild(el);
      });

      // draw waits as dashed arrows from process -> resource (colored by cycle)
      state.waits.forEach(w=>{
        const from = procPositions[w.proc]; const to = resPositions[w.res];
        if(!from||!to) return;
        const path = makeArrowPath(from.x+28, from.y, to.x-28, to.y);
        const el = createPathElement(path, 'wait'); svg.appendChild(el);
      });

      // Draw nodes (resources & processes)
      // first resources
      state.resources.forEach(r=>{
        const pos = resPositions[r]; if(!pos) return;
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('transform',`translate(${pos.x},${pos.y})`);
        const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rect.setAttribute('x',-28); rect.setAttribute('y',-18); rect.setAttribute('width',56); rect.setAttribute('height',36); rect.setAttribute('rx',6);
        rect.setAttribute('fill','#0b2540'); rect.setAttribute('stroke','rgba(255,255,255,0.03)'); rect.setAttribute('stroke-width',1);
        const txt = document.createElementNS('http://www.w3.org/2000/svg','text'); txt.setAttribute('x',0); txt.setAttribute('y',5); txt.setAttribute('text-anchor','middle'); txt.setAttribute('font-size','12'); txt.textContent = r;
        txt.setAttribute('fill','#bfe0ff'); g.appendChild(rect); g.appendChild(txt); svg.appendChild(g);
      });

      // processes
      state.processes.forEach(p=>{
        const pos = procPositions[p]; if(!pos) return;
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('transform',`translate(${pos.x},${pos.y})`);
        const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circ.setAttribute('r',18); circ.setAttribute('fill','#042b46'); circ.setAttribute('stroke','rgba(255,255,255,0.03)'); circ.setAttribute('stroke-width',1);
        const txt = document.createElementNS('http://www.w3.org/2000/svg','text'); txt.setAttribute('x',0); txt.setAttribute('y',5); txt.setAttribute('text-anchor','middle'); txt.setAttribute('font-size','12'); txt.textContent = p;
        txt.setAttribute('fill','#bfe0ff'); g.appendChild(circ); g.appendChild(txt); svg.appendChild(g);
      });

      // if cycle provided, highlight implicated edges and nodes
      if(cycle){
        // cycle is array like [A,B,C,A]; nodes in cycle are unique elements except last repeated
        const nodes = Array.from(new Set(cycle.slice(0,-1)));
        // highlight nodes
        nodes.forEach(n=>{
          // find process? Only processes are nodes in WFG
          const pos = procPositions[n]; if(pos){
            const highlight = document.createElementNS('http://www.w3.org/2000/svg','circle');
            highlight.setAttribute('cx',pos.x); highlight.setAttribute('cy',pos.y); highlight.setAttribute('r',28); highlight.setAttribute('fill','none'); highlight.setAttribute('stroke',getComputedStyle(document.documentElement).getPropertyValue('--danger')||'#fb7185'); highlight.setAttribute('stroke-width',3); svg.appendChild(highlight);
          }
        });

        // highlight edges between processes according to waits->holders mapping
        for(let i=0;i<cycle.length-1;i++){
          const a = cycle[i]; const b = cycle[i+1];
          // find resource(s) that cause a -> b (i.e., a waits for res held by b)
          const matched = state.waits.filter(w=> w.proc===a).map(w=> state.holds.filter(h=>h.res===w.res && h.proc===b).map(h=>h.res)).flat();
          matched.forEach(resName=>{
            const from = procPositions[a]; const to = resPositions[resName];
            if(!from||!to) return;
            const path = makeArrowPath(from.x+28, from.y, to.x-28, to.y);
            const el = createPathElement(path,'cycle'); svg.appendChild(el);
            // also draw resource->holding process edge as highlight
            const holdPath = makeArrowPath(to.x-28, to.y, procPositions[b].x+28, procPositions[b].y);
            const el2 = createPathElement(holdPath,'cycle'); svg.appendChild(el2);
          });
        }
      }
    }

    function makeArrowPath(x1,y1,x2,y2){
      // simple curved path
      const dx = Math.abs(x2-x1);
      const dy = y2-y1;
      const cx1 = x1 + (x2-x1)/2;
      const cy1 = y1;
      const cx2 = x1 + (x2-x1)/2;
      const cy2 = y2;
      return `M ${x1} ${y1} C ${cx1} ${cy1} ${cx2} ${cy2} ${x2} ${y2}`;
    }

    function createPathElement(d, type){
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d', d);
      path.setAttribute('fill','none');
      if(type==='hold'){
        path.setAttribute('stroke','rgba(100,200,255,0.12)'); path.setAttribute('stroke-width','2');
        // add arrowhead
      } else if(type==='wait'){
        path.setAttribute('stroke','rgba(160,200,255,0.18)'); path.setAttribute('stroke-width','2'); path.setAttribute('stroke-dasharray','6,6');
      } else if(type==='cycle'){
        path.setAttribute('stroke',getComputedStyle(document.documentElement).getPropertyValue('--danger')||'#fb7185'); path.setAttribute('stroke-width','3');
      }
      return path;
    }

    // Analysis
    detectBtn.onclick = ()=>{
      const graph = buildWaitForGraph();
      const cycle = findCycle(graph);
      if(cycle){
        resultTitle.textContent = 'Deadlock Detected ☠️';
        resultBody.innerHTML = `<div style="color:var(--muted)">A cycle was found in the wait-for graph: <strong>${cycle.join(' → ')}</strong></div>`;
        drawGraph(cycle);
      } else {
        resultTitle.textContent = 'No Deadlock Detected ✅';
        resultBody.textContent = 'No cycles found in the wait-for graph.';
        drawGraph();
      }
    }

    // Download report
    downloadReport.onclick = ()=>{
      const graph = buildWaitForGraph();
      const cycle = findCycle(graph);
      const report = {
        timestamp: new Date().toISOString(),
        processes: state.processes.slice(),
        resources: state.resources.slice(),
        holds: state.holds.slice(),
        waits: state.waits.slice(),
        waitForGraph: graph,
        cycle: cycle
      };
      const blob = new Blob([JSON.stringify(report,null,2)],{type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download = `deadlock-report-${Date.now()}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }

    // initial draw
    refreshSelects(); drawGraph();

    // expose helpers for inline onclick usage (remove etc.)
    window.removeProc = removeProc; window.removeRes = removeRes; window.removeHold = removeHold; window.removeWait = removeWait; window.drawGraph = drawGraph;
  </script>
</body>
</html>
